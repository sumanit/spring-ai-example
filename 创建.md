
# 一、Flux
示例见 CreateFlux.java
参考资料：
https://cloud.tencent.com/developer/article/2304019
## （一） 创建FLux
### 1. 从静态数据创建
- `Flux.empty()` - 创建一个空的Flux
- `Flux.just(1,2,3)` - 直接创建包含多个数据的Flux
- `Flux.fromArray(new Integer[]{1,2,3})` - 从数组创建
- `Flux.fromIterable(Lists.newArrayList(1, 2, 3))` - 从Iterable集合创建

### 2. 从流式数据创建
- `Flux.fromStream(Stream.of(1,2,3))` - 从Stream创建
- `Flux.fromStream(()->Stream.of(1,2,3))` - 从streamSupplier创建

### 3. 从发布者创建
- `Flux.from(new MyPublisher())` - 从Publisher创建

### 4. 数值范围创建
- `Flux.range(1, 10)` - 创建包含1到10整数的Flux

### 5. 定时序列创建
- `Flux.interval(Duration.ofSeconds(1))` - 每秒发射一个递增长整数的Flux
- `Flux.interval(Duration.ofSeconds(1), Duration.ofSeconds(2))` - 延迟1秒开始，每2秒发射一次
- `Flux.interval(Duration.ofSeconds(1),Schedulers.parallel())` - 指定调度器的定时Flux
- `Flux.interval(Duration.ofSeconds(1), Duration.ofSeconds(2), Schedulers.parallel())` - 带延迟和调度器的定时Flux

### 6. 通过generate创建
- `Flux.generate(sink -> {sink.next(1);sink.complete();});` - 通过同步生成器创建Flux
- `Flux.generate(AtomicLong::new, (state, sink) -> { long i = state.getAndIncrement(); sink.next(i); if (i == 10) { sink.complete(); } return state; });` - 带状态的同步生成器创建Flux
- `Flux.generate(AtomicInteger::new, (state, sink) -> {long i = state.getAndIncrement();sink.next(i);if (i == 10) {sink.complete();} return state;}, state -> state.set(0)` - 带状态的同步生成器创建Flux

### 7. 特殊类型创建
- `Flux.error(new RuntimeException("error"))` - 创建一个只包含错误信号的Flux
- `Flux.never()` - 创建一个永远不会发射任何数据的Flux
- `Flux.defer(()->Flux.just(1,2,3))` - 延迟创建Flux，直到有订阅者订阅时才执行

## （二）Flux源码分析
### 1. 常见子类实现
- `FluxEmpty` - 通过静态数据创建的Flux实现
- `FluxArray` - 通过数组创建的Flux实现
- `FluxIterable` - 通过Iterable集合创建的Flux实现
- `FluxRange` - 通过数值范围创建的Flux实现
- `FluxInterval` - 通过定时器创建的Flux实现
- `FluxStream` - 通过Stream创建的Flux实现
- `FluxError` - 通过错误信号创建的Flux实现
- `FluxNever` - 永远不会发射数据的Flux实现
- `FluxDefer` - 延迟创建的Flux实现
- `FluxGenerate` - 通过生成器创建的Flux实现
### 2. onAssembly 方法
一般创建都会使用 `onAssembly` 方法进行包装，添加一些通用功能
```java
	protected static <T> Flux<T> onAssembly(Flux<T> source) {
		Function<Publisher, Publisher> hook = Hooks.onEachOperatorHook;
		if(hook != null) {
			source = (Flux<T>) hook.apply(source);
		}
		if (Hooks.GLOBAL_TRACE) {
			AssemblySnapshot stacktrace = new AssemblySnapshot(null, Traces.callSiteSupplierFactory.get());
			source = (Flux<T>) Hooks.addAssemblyInfo(source, stacktrace);
		}
		return source;
	}
```
- `Hooks.onEachOperatorHook` - 通过钩子函数对Flux进行包装
- `Hooks.addAssemblyInfo(source, stacktrace)` 增加全局链路追踪

# Mono
## 创建Mono
### 从静态数据创建
- `Mono.just("Hello, Mono!")` - 创建一个元素的Mono
- `Mono.empty()` - 创建一个空的Mono
- `Mono.justOrEmpty(null)` - 创建一个元素或空的Mono
- `Mono.justOrEmpty(Optional.of(null))` - 从Optional创建一个元素或空的Mono

### 从CompletableFuture创建
- `Mono.fromFuture(CompletableFuture.supplyAsync(()->null))` - 从CompletableFuture创建Mono
- `Mono.fromFuture(()->CompletableFuture.supplyAsync(()->null))` - 从CompletableFuture Supplier创建Mono
- `Mono.fromFuture(CompletableFuture.supplyAsync(()->null),true)` - 从CompletableFuture创建Mono，并在取消时取消Future
- `Mono.fromFuture(()->CompletableFuture.supplyAsync(()->null),true)` - 从CompletableFuture Supplier创建Mono，并在取消时取消Future

### 从CompletionStage创建
- `Mono.fromCompletionStage(CompletableFuture.supplyAsync(()->null))` - 从CompletionStage创建Mono
- `Mono.fromCompletionStage(()->CompletableFuture.supplyAsync(()->null))` - 从CompletionStage Supplier创建Mono

### 从发布者创建
- `Mono.from(new MyPublisher())` - 从Publisher创建Mono

### 从lambda表达式创建
- `Mono.fromRunnable(()->{})` - 从Runnable创建Mono，执行完毕后发出完成信号
- `Mono.fromCallable(()->null)` - 从Callable创建Mono，发出Callable的返回值
- `Mono.fromSupplier(()->null)` - 从Supplier创建Mono，发出Supplier的返回值


### 延迟发射创建
- `Mono.delay(Duration.ofSeconds(1))` - 创建一个在指定延迟后发出0的Mono
- `Mono.delay(Duration.ofSeconds(1),  Schedulers.parallel())` - 创建一个在指定延迟后发出的Mono，并指定调度器

### 其他创建方式
- `Mono.never()` - 创建一个永远不会发射任何数据的Mono
- `Mono.fromDirect(new MyPublisher())` - 创建的 Mono 对象在订阅时会立即执行，但不会阻塞当前线程
- `Mono.defer(()->Mono.just("Deferred Mono"))` - 延迟创建Mono，直到有订阅者订阅时才执行
- `Mono.error(()->new RuntimeException("Error Mono from Supplier"))` - 从Supplier创建一个只包含错误信号的Mono
- `Mono.error(new RuntimeException("Error Mono"))` - 创建一个只包含错误信号的Mono
- `Mono.create(sink -> sink.success("Created Mono"))` - 通过MonoSink手动创建Mono
- `Mono.deferContextual(ctx -> Mono.just("Contextual Mono"))` - 创建一个可以访问上下文信息的Mono
## （二）Mono源码分析
### 1. 常见子类实现
- `MonoJust` - 通过静态数据创建的Mono实现
- `MonoNever` - 永远不会发射数据的Mono实现
- `MonoCompletionStage` - 通过CompletionStage创建的Mono实现
- `MonoRunnable` - 通过Runnable创建的Mono实现
- `MonoDelay` - 通过延迟创建的Mono实现
- `MonoDefer` - 延迟创建的Mono实现
- `MonoSupplier` - 通过Supplier创建的Mono实现
- `MonoCallable` - 通过Callable创建的Mono实现
- `MonoError` - 通过错误信号创建的Mono实现
- `MonoCreate` - 通过MonoSink创建的Mono实现
- `MonoDeferContextual` - 通过上下文创建的Mono实现

### 2. onAssembly 方法
一般创建都会使用 `onAssembly` 方法进行包装，添加一些通用功能
```java
	protected static <T> Flux<T> onAssembly(Flux<T> source) {
		Function<Publisher, Publisher> hook = Hooks.onEachOperatorHook;
		if(hook != null) {
			source = (Flux<T>) hook.apply(source);
		}
		if (Hooks.GLOBAL_TRACE) {
			AssemblySnapshot stacktrace = new AssemblySnapshot(null, Traces.callSiteSupplierFactory.get());
			source = (Flux<T>) Hooks.addAssemblyInfo(source, stacktrace);
		}
		return source;
	}
```
- `Hooks.onEachOperatorHook` - 通过钩子函数对Flux进行包装
- `Hooks.addAssemblyInfo(source, stacktrace)` 增加全局链路追踪