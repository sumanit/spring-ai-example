# 操作符的分类
在进行响应式编程时，灵活应用操作符是开发人员的核心工作。由于 Reactor 中所提供的操作符数量众多，本课程不打算对所有这些操作符进行全面而细致的介绍，而是尝试将操作符进行分类，然后对每一类中具有代表性的操作符展开讨论。
业界关于响应式操作符的分类并没有统一的说法，但针对数据流通常都会涉及转换、过滤、裁剪等核心操作，以及一些辅助性的操作。因此，本课程中我将 Flux 和 Mono 操作符分成如下六大类型：
- 转换（Transforming）操作符，负责将序列中的元素转变成另一种元素；
- 过滤（Filtering）操作符，负责将不需要的数据从序列中剔除出去；
- 组合（Combining）操作符，负责将序列中的元素进行合并、连接和集成；
- 条件（Conditional）操作符，负责根据特定条件对序列中的元素进行处理；
- 裁剪（Reducing）操作符，负责对序列中的元素执行各种自定义的裁剪操作；
- 工具（Utility）操作符，负责一些针对流式处理的辅助性操作。

# 操作符也是一种Flux或者Mono的实现
- Flux
  - FluxOperator
    - InternalFluxOperator

# 转换操作符
转换可以说是对数据流最常见的一种操作了，Reactor 中常用的转换操作符包括 buffer、window、map 和 flatMap 等。

## buffer
可以将数据缓存下来 然后打包成list 发射给后续流程处理

| 重载方法                                                     | 说明                                                         | 使用场景                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| buffer()                                                     | 无参数版本，收集所有元素直到流结束                           | 完整数据最后一起处理                                         |
| buffer                                                       | 固定大小窗口缓冲                                             | 固定包大小的网络传输（如每100ms/50条数据发送）               |
| buffer(int maxSize, Supplier<C> bufferSupplier)              | 带自定义容器实现的固定缓冲                                   | 需要特殊集合类型时（如ConcurrentLinkedQueue）                |
| buffer(int maxSize, int skip)                                | 固定大小窗口缓冲，缓冲区满时跳过指定数量的旧元素再写入新数据 | 实时数据流处理中保留最新样本                                 |
| buffer(int maxSize, int skip, Supplier<C> bufferSupplier)    | 带自定义容器实现的固定大小窗口缓冲，缓冲区满时跳过指定数量的旧元素再写入新数据 | 需要特殊集合类型时（如ConcurrentLinkedQueue                  |
| buffer(Publisher<?> other)                                   | 创建一个缓冲区，订阅指定Publisher的数据流并缓存其发出的元素  | 响应式编程中需要缓存上游数据源的场景（如背压处理、数据批处理） |
| buffer(Publisher<?> other, Supplier<C> bufferSupplier)       | 创建一个带自定义容器实现的缓冲区，订阅指定Publisher的数据流并缓存其发出的元素 | 需要特殊集合类型时（如ConcurrentLinkedQueue                  |
| buffer(Duration bufferingTimespan)                           | 按时间窗口缓冲                                               | 数据每分钟聚合为一个list                                     |
| buffer(Duration bufferingTimespan, Duration openBufferEvery) | 创建一个基于时间窗口的缓冲区，按固定间隔开启新缓冲区并收集指定时间范围内的数据 | 流式数据处理中需要按时间分批次处理的场景                     |
| buffer(Duration bufferingTimespan, Scheduler timer)          | 创建一个基于时间窗口的缓冲区，在指定时间间隔内收集数据并通过`Scheduler`控制时间窗口的线程调度 | 需要周期性批量处理流式数据的场景                             |
| buffer(Duration bufferingTimespan, Duration openBufferEvery, Scheduler timer) | 创建一个基于时间窗口的缓冲区，按固定间隔开启新缓冲区并收集指定时间范围内的数据并通过`Scheduler`控制时间窗口的线程调度 | 流式数据处理中需要按时间分批次处理的场景                     |
| bufferTimeout(int maxSize, Duration maxTime)                 | 当元素数量达到`maxSize`或时间超过`maxTime`时触发缓冲         | 满足100条或200ms强制发送                                     |
| bufferTimeout(int maxSize, Duration maxTime, Supplier<C> bufferSupplier) | 当元素数量达到`maxSize`或时间超过`maxTime`时触发缓冲，并使用`bufferSupplier`自定义缓冲区容器类型 | 需要特殊集合类型时（如ConcurrentLinkedQueue）                |
| bufferTimeout(int maxSize, Duration maxTime, Scheduler timer) | 当元素数量达到`maxSize`或时间超过`maxTime`时触发缓冲，并通过`Scheduler`控制时间窗口的线程调度。 | 适用于需要同时控制缓冲数据量（如批量处理）和时间间隔（如实时日志聚合）的流式数据处理 |
| bufferTimeout(int maxSize, Duration maxTime, Scheduler timer, Supplier<C> bufferSupplier) | 当元素数量达到`maxSize`或时间超过`maxTime`时触发缓冲，通过`Scheduler`控制时间窗口调度，并使用`bufferSupplier`自定义缓冲区容器类型 | 适用于需要同时控制缓冲量、时间窗口且需自定义缓冲区结构（如优先队列）的流式数据处理 |
| bufferTimeout(int maxSize, Duration maxTime, boolean fairBackpressure) | 当元素数量达到`maxSize`或时间超过`maxTime`时触发缓冲，并通过`fairBackpressure`控制背压策略的公平性 | 适用于需要平衡缓冲效率与下游处理能力的场景（如高吞吐量数据流中防止下游过载） |
| bufferTimeout(int maxSize, Duration maxTime, Scheduler timer, boolean fairBackpressure) | 当缓冲元素数量达到`maxSize`或时间超过`maxTime`时触发数据发射，通过`Scheduler`控制时间窗口调度，并通过`fairBackpressure`平衡背压策略的公平性 | 适用于需要同时控制缓冲量、时间窗口且需自定义缓冲区结构（如优先队列）的流式数据处理 |
| bufferTimeout(int maxSize, Duration maxTime, Supplier<C> bufferSupplier, boolean fairBackpressure) | 当缓冲元素数量达到`maxSize`或时间超过`maxTime`时触发数据发射，通过`bufferSupplier`自定义缓冲区容器类型，并通过`fairBackpressure`平衡背压策略的公平性 | 适用于需要同时控制缓冲量、时间窗口且需自定义缓冲区结构（如优先队列）的流式数据处理 |
| bufferTimeout(int maxSize, Duration maxTime, Scheduler timer, Supplier<C> bufferSupplier, boolean fairBackpressure) | 当缓冲元素数量达到`maxSize`或时间超过`maxTime`时触发数据发射，通过`Scheduler`控制时间窗口调度，通过`bufferSupplier`自定义缓冲区容器类型，并通过`fairBackpressure`平衡背压策略的公平性 | 适用于需要同时控制缓冲量、时间窗口且需自定义缓冲区结构（如优先队列）的流式数据处理 |
| bufferUntil(Predicate<? super T> predicate)                  | 缓冲数据直到满足条件后触发数据发射                           | ：适用于需要按条件分段处理数据的场景                         |
| bufferUntil(Predicate<? super T> predicate, boolean cutBefore) | 缓冲数据直到满足条件后触发数据发射`cutBefore`参数决定是否包含触发条件的元素 | 适用于需要按条件分段处理数据的场景                           |
| bufferUntilChanged()                                         | 值变化时触发缓冲                                             | 适用于需要按动态条件分批次处理数据的场景                     |
| bufferUntilChanged(Function<? super T, ? extends V> keySelector) | 值变化时触发缓冲 (指定对象属性)                              | 适用于需要按数据特征变化分组的场景                           |
| bufferUntilChanged(Function<? super T, ? extends V> keySelector,        BiPredicate<? super V, ? super V> keyComparator) | 根据`keySelector`提取的键值和`keyComparator`比较结果，在键值变化时触发缓冲区释放 | 适用于需要按数据特征变化分组的场景                           |
| bufferWhile(Predicate<? super T> predicate)                  | 持续收集元素到缓冲区，直到条件不再满足时触发数据发射         | 适用于需要连续采集符合条件数据的场景                         |
| bufferWhen(Publisher<U> bucketOpening,  Function<? super U, ? extends Publisher<V>> closeSelector) | 通过`bucketOpening`触发缓冲区的开启，并通过`closeSelector`动态决定缓冲区关闭时机 |                                                              |
| bufferWhen(Publisher<U> bucketOpening, Function<? super U, ? extends Publisher<V>> closeSelector, Supplier<C> bufferSupplier) | 通过`bucketOpening`触发缓冲区的开启，并通过`closeSelector`动态决定缓冲区关闭时机，`bufferSupplier`提供自定义缓冲区容器 |                                                              |
|                                                              |                                                              |                                                              |

## map
用于数据转换，在订阅后同步执行

## flatMap
用于数据转换，可以并发处理

| 重载方法                                                     | 说明                                                         | 使用场景                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ----------------------------------------------------- |
| flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper) | 将每个元素转换为新的流并合并 默认并发度256                   |                                                       |
| flatMap(Function<? super T, ? extends Publisher<? extends V>> mapper, int concurrency) | 将每个元素转换为新的流并合并，`concurrency`参数控制并发处理的子流数量 | 需要并行处理多个异步任务（如批量API调用）时限制并发度 |
| flatMap(Function<? super T, ? extends Publisher<? extends V>> mapper, int concurrency, int prefetch) | 将每个元素转换为新的流并合并，`concurrency`参数控制并发处理的子流数量 `prefetch` 参数控制预取数量 |                                                       |
|                                                              |                                                              |                                                       |

